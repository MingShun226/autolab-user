<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <title>Shopping Cart - Autolabs</title>
    <style>
        /* Import Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        /* Soft Red Color Palette Variables */
        :root {
            /* Primary Colors - Soft Red */
            --primary-50: #fef2f2;
            --primary-100: #fee2e2;
            --primary-200: #fecaca;
            --primary-300: #fca5a5;
            --primary-400: #f87171;
            --primary-500: #ef4444;
            --primary-600: #dc2626;
            --primary-700: #b91c1c;
            --primary-800: #991b1b;
            --primary-900: #7f1d1d;
            
            /* Secondary Colors - Warm Red */
            --secondary-50: #fff7ed;
            --secondary-100: #ffedd5;
            --secondary-200: #fed7aa;
            --secondary-300: #fdba74;
            --secondary-400: #fb923c;
            --secondary-500: #f97316;
            --secondary-600: #ea580c;
            --secondary-700: #c2410c;
            --secondary-800: #9a3412;
            --secondary-900: #7c2d12;
            
            /* Neutral Colors - Warm Grays */
            --neutral-50: #fafaf9;
            --neutral-100: #f5f5f4;
            --neutral-200: #e7e5e4;
            --neutral-300: #d6d3d1;
            --neutral-400: #a8a29e;
            --neutral-500: #78716c;
            --neutral-600: #57534e;
            --neutral-700: #44403c;
            --neutral-800: #292524;
            --neutral-900: #1c1917;
            
            /* Status Colors - Soft tones */
            --success-light: #d1fae5;
            --success: #10b981;
            --success-dark: #047857;
            
            --warning-light: #fef3c7;
            --warning: #f59e0b;
            --warning-dark: #d97706;
            
            --error-light: var(--primary-100);
            --error: var(--primary-500);
            --error-dark: var(--primary-700);
        }
        
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--neutral-50) 0%, var(--primary-50) 50%, var(--secondary-50) 100%);
            display: flex;
            min-height: 100vh;
            animation: backgroundShift 30s ease-in-out infinite alternate;
            color: var(--neutral-800);
        }
        
        @keyframes backgroundShift {
            0% { background: linear-gradient(135deg, var(--neutral-50) 0%, var(--primary-50) 50%, var(--secondary-50) 100%); }
            50% { background: linear-gradient(135deg, var(--primary-50) 0%, var(--secondary-50) 50%, var(--neutral-50) 100%); }
            100% { background: linear-gradient(135deg, var(--secondary-50) 0%, var(--neutral-50) 50%, var(--primary-50) 100%); }
        }

        /* Sidebar Styles */
        .logo {
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            margin-right: auto;
            text-decoration: none;
        }

        a {
            text-decoration: none;
            /* Remove underline for all links */
        }

        .header>div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .logo svg {
            margin-right: 10px;
        }

        .logo span {
            color: var(--neutral-700);
            position: relative;
        }

        .logo span::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 2px;
            bottom: -4px;
            left: 0;
            background: linear-gradient(90deg, var(--primary-500), var(--secondary-400));
            transform: scaleX(1);
            border-radius: 1px;
        }

        .nav-item {
            padding: 15px 20px;
            display: flex;
            align-items: center;
            color: white;
            text-decoration: none;
            transition: background 0.3s;
        }

        .nav-item svg {
            margin-right: 15px;
        }

        .nav-item:hover {
            background-color: #444;
        }

        .nav-item.active {
            background-color: #e21b1b;
        }

        /* Main Content Area */
        .main-content {
            width: 100%;
            padding: 40px;
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.7);
            border-radius: 24px;
            margin: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08), 0 8px 25px rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.9);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--neutral-200);
        }

        .header h1 {
            font-size: 32px;
            color: var(--neutral-800);
            font-weight: 600;
            background: linear-gradient(135deg, var(--primary-600), var(--secondary-600));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .user-actions {
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            z-index: 9999 !important;
        }

        .cart-icon,
        .notifications,
        .user-avatar {
            position: relative;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.3s;
        }

        .cart-icon:hover,
        .notifications:hover {
            background-color: var(--neutral-100);
        }

        .cart-count,
        .notifications-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background: linear-gradient(135deg, var(--primary-400), var(--primary-500));
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }

        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
            transition: all 0.3s ease;
        }
        
        .user-avatar:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        .user-info {
            display: flex;
            align-items: center;
            position: relative;
            z-index: 100;
            margin-right: 20px;
            top: -5px;
        }

        .dropdown-menu {
            position: absolute;
            top: 45px;
            left: 0;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            padding: 8px 0;
            min-width: 200px;
            display: none;
            z-index: 101;
        }

        .dropdown-menu.active {
            display: block;
        }

        .dropdown-item {
            padding: 8px 16px;
            display: block;
            color: var(--neutral-700);
        }

        .dropdown-divider {
            height: 1px;
            background-color: var(--neutral-200);
            margin: 8px 0;
        }

        .dropdown-item.logout {
            color: var(--primary-500);
            cursor: pointer;
        }

        .dropdown-item.logout:hover,
        .dropdown-item.order:hover {
            background-color: var(--neutral-100);
        }

        .header-icons {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }

        /* Cart Content */
        .cart-container {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }

        .cart-items {
            flex: 2;
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .order-summary {
            flex: 1;
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            height: fit-content;
        }

        .cart-title,
        .summary-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--neutral-700);
            margin-bottom: 20px;
        }

        .cart-item {
            display: flex;
            border-bottom: 1px solid var(--neutral-200);
            padding: 20px 0;
        }

        .cart-item-image {
            width: 100px;
            height: 100px;
            background-color: var(--neutral-100);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 20px;
            overflow: hidden;
            /* Added to contain the image */
        }

        .cart-item-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .cart-item-details {
            flex: 1;
        }

        .cart-item-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--neutral-700);
            margin-bottom: 5px;
        }

        .cart-item-sku {
            font-size: 14px;
            color: var(--neutral-500);
            margin-bottom: 10px;
        }

        .cart-item-price {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-500);
        }

        .cart-item-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .quantity-control {
            display: flex;
            align-items: center;
            border: 1px solid var(--neutral-200);
            border-radius: 4px;
            overflow: hidden;
        }

        .quantity-btn {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--neutral-100);
            border: none;
            cursor: pointer;
        }

        .quantity-input {
            width: 40px;
            height: 30px;
            border: none;
            border-left: 1px solid #e9ecef;
            border-right: 1px solid #e9ecef;
            text-align: center;
        }

        .remove-item {
            color: var(--neutral-500);
            cursor: pointer;
            transition: color 0.3s;
        }

        .remove-item:hover {
            color: var(--primary-500);
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            font-size: 16px;
            color: var(--neutral-700);
        }

        .summary-row.total {
            font-size: 20px;
            font-weight: 600;
            border-top: 1px solid #e9ecef;
            margin-top: 10px;
            padding-top: 20px;
        }

        .checkout-btn {
            padding: 15px;
            background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .checkout-btn:hover {
            background: linear-gradient(135deg, var(--primary-600), var(--secondary-500));
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        .checkout-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .checkout-btn {
            flex: 1;
            white-space: nowrap;
        }

        .checkout-btn.without-payment {
            background-color: #555;
        }

        .checkout-btn.without-payment:hover {
            background-color: #444;
        }

        .continue-shopping {
            display: inline-block;
            padding: 15px 25px;
            background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
            color: white;
            border-radius: 8px;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.3s ease;
            border: none;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .continue-shopping:hover {
            background: linear-gradient(135deg, var(--primary-600), var(--secondary-500));
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        .empty-cart {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 0;
        }

        .empty-cart svg {
            color: var(--primary-500);
            margin-bottom: 20px;
        }

        .empty-cart-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--neutral-700);
            margin-bottom: 10px;
        }

        .empty-cart-subtitle {
            font-size: 16px;
            color: var(--neutral-500);
            margin-bottom: 30px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .main-content {
                padding: 15px;
            }

            .cart-container {
                flex-direction: column;
            }

            .header {
                flex-direction: column;
                align-items: center;
                gap: 12px;
                margin-bottom: 20px;
            }

            .header>div {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                width: 100%;
            }

            .header>div>div {
                width: 100%;
                justify-content: space-between;
                /* User avatar left, icons right */
            }

            .logo {
                margin-bottom: 10px;
                align-self: center;
            }


            .user-actions {
                width: 100%;
                justify-content: space-between;
            }

            .header-icons {
                margin-left: 0;
            }

            .user-info {
                margin-right: 20px;
                top: 0;
            }

            /* Fix dropdown positioning on mobile */
            .dropdown-menu {
                left: 0;
                /* Align to right edge */
                width: 100%;
                max-width: 250px;
            }

            .cart-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .cart-item-image {
                margin-bottom: 15px;
            }

            .cart-item-actions {
                margin-top: 15px;
                width: 100%;
                justify-content: space-between;
            }

            .checkout-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="main-content">
        <div class="header">
            <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                <!-- Logo (replacing user-info position) -->
                <a href="catalog.html">
                    <div class="logo">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="var(--primary-500)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="8"></circle>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        <span style="color: var(--neutral-700); font-weight: bold;">Autolabs</span>
                    </div>
                </a>
                <!-- Group user info and icons together -->
                <div style="display: flex; align-items: center; gap: 20px;">
                    <!-- User info (moved next to header-icons) -->
                    <div class="user-info">
                        <div class="user-avatar" id="userAvatar">
                            CU
                        </div>
                        <div>
                            <div style="font-weight: 500;" id="userName">Customer Name</div>
                            <div style="font-size: 12px; color: #555;">Customer</div>
                        </div>
                        <!-- Dropdown menu -->
                        <div class="dropdown-menu" id="userDropdown">
                            <div class="dropdown-item order"><a href="MyAccount.html"
                                    style="text-decoration: none; color: inherit;">My Account</a></div>
                            <div class="dropdown-divider"></div>
                            <div class="dropdown-item order"><a href="myorder.html"
                                    style="text-decoration: none; color: inherit;">My Orders</a></div>
                            <div class="dropdown-divider"></div>
                            <div class="dropdown-item logout" id="logoutButton">Logout</div>
                        </div>
                    </div>

                    <!-- Cart and notification icons (remains the same) -->
                    <div class="header-icons">
                        <a href="cart.html" class="cart-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="#e21b1b" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <circle cx="9" cy="21" r="1"></circle>
                                <circle cx="20" cy="21" r="1"></circle>
                                <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                            </svg>
                            <span class="cart-count" id="cartCount">0</span>
                        </a>
                        <div class="notifications">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                                <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                            </svg>
                            <span class="notifications-count">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="cart-container">
            <!-- Cart Items Section -->
            <div class="cart-items">
                <!-- Empty Cart State (Initially shown) -->
                <div id="emptyCartState" class="empty-cart">
                    <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="9" cy="21" r="1"></circle>
                        <circle cx="20" cy="21" r="1"></circle>
                        <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                    </svg>
                    <div class="empty-cart-title">Your cart is empty</div>
                    <div class="empty-cart-subtitle">Looks like you haven't added any items to your cart yet.</div>
                    <a href="catalog.html" class="continue-shopping">Continue Shopping</a>
                </div>

                <!-- Cart Items List (Hidden until items are added) -->
                <div id="cartItemsList" style="display: none;">
                    <div class="cart-title" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>Shopping Cart</span>
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="select-all-items" checked>
                            <label for="select-all-items"
                                style="margin-left: 8px; font-size: 14px; font-weight: normal;">Select All</label>
                        </div>
                    </div>
                    <div id="cartItemsContainer">
                        <div class="cart-item">
                            <div style="display: flex; align-items: center; margin-right: 15px;">
                                <input type="checkbox" id="select-item-{item.id}" class="item-checkbox" checked>
                            </div>
                            <div class="cart-item-image">
                                <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24"
                                    fill="none" stroke="#999" stroke-width="1" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <circle cx="12" cy="12" r="6"></circle>
                                    <circle cx="12" cy="12" r="2"></circle>
                                </svg>
                            </div>
                            <div class="cart-item-details">
                                <div class="cart-item-name">${item.product.name}</div>
                                <div class="cart-item-sku">${item.product.product_id}</div>
                                <div class="cart-item-price">
                    RM ${item.product.price.toFixed(2)}
                    ${item.product.isMerchantPrice ? '<span style="color: var(--secondary-600); font-size: 12px; display: block;">(B2B Price)</span>' : ''}
                </div>
                            </div>
                            <div class="cart-item-actions">
                                <div class="quantity-control">
                                    <button class="quantity-btn minus-btn" data-id="${item.id}">-</button>
                                    <input type="number" class="quantity-input" value="${item.quantity}" min="1"
                                        data-id="${item.id}">
                                    <button class="quantity-btn plus-btn" data-id="${item.id}">+</button>
                                </div>
                                <div class="remove-item" data-id="${item.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path
                                            d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                                        </path>
                                        <line x1="10" y1="11" x2="10" y2="17"></line>
                                        <line x1="14" y1="11" x2="14" y2="17"></line>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Order Summary Section -->
            <div class="order-summary" id="orderSummary">
                <div class="summary-title">Order Summary</div>
                <div class="summary-row">
                    <div>Subtotal</div>
                    <div id="subtotalAmount">RM 0.00</div>
                </div>
                <div class="summary-row total">
                    <div>Total</div>
                    <div id="totalAmount">RM 0.00</div>
                </div>
                <div id="selectedItemsTotal"
                    style="display: none; font-size: 14px; color: var(--primary-500); margin-top: 5px; text-align: right;">
                    Selected: RM 0.00
                </div>
                <div class="checkout-buttons">
                    <button class="checkout-btn" id="checkoutBtn" disabled>Checkout</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Supabase configuration
        const supabaseUrl = 'https://bbwimjvqpyxwhovihtfm.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJid2ltanZxcHl4d2hvdmlodGZtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0MjAwMDksImV4cCI6MjA2MDk5NjAwOX0._D3wackPNKg-IbiswH7M-3wqeQRP6ujMmcJ9bb7_1z0';
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey, {
            auth: {
                persistSession: true,
                storage: window.localStorage,
                autoRefreshToken: true,
                detectSessionInUrl: false
            }
        });

        // n8n Webhook Configuration
        const N8N_WEBHOOK_URL = 'https://apipietech.app.n8n.cloud/webhook/unified-whatsapp';
        // Your actual n8n webhook URL for purchase detection

        // Enhanced function to send order notification to n8n with detailed debugging
        async function sendOrderToN8n(orderData, customerData, retryCount = 0) {
    const MAX_RETRIES = 3;
    const RETRY_DELAYS = [1000, 2000, 5000]; // Progressive delay

    try {
        console.log(`üöÄ Sending order to n8n (attempt ${retryCount + 1}/${MAX_RETRIES + 1})`);
        console.log('üìã Order Data:', orderData);
        console.log('üë§ Customer Data:', customerData);

        // ENHANCED PHONE NUMBER HANDLING
        let customerPhone = null;
        
        // Try multiple sources for phone number
        const phoneSources = [
            customerData.phone,
            customerData.customer_phone,
            customerData.phoneNumber,
            orderData.customerPhone
        ];
        
        for (const phone of phoneSources) {
            if (phone && phone !== 'N/A' && phone !== null && phone !== undefined) {
                customerPhone = standardizePhoneNumber(phone);
                break;
            }
        }
        
        // If still no phone, try getting from Supabase auth
        if (!customerPhone) {
            console.warn('‚ö†Ô∏è No phone in customer data, checking auth user...');
            try {
                const { data: { user }, error: authError } = await supabase.auth.getUser();
                if (!authError && user && user.phone) {
                    customerPhone = standardizePhoneNumber(user.phone);
                    console.log('‚úÖ Found phone from auth user:', customerPhone);
                }
            } catch (authErr) {
                console.warn('Could not get auth user phone:', authErr);
            }
        }
        
        // Final validation
        if (!customerPhone) {
            console.error('‚ùå CRITICAL: No phone number available!');
            // Still send to n8n but with a flag
            customerPhone = 'NO_PHONE_' + (customerData.customer_id || 'UNKNOWN');
        }

        console.log('üì± Final phone number:', customerPhone);

        // IMPROVED PAYLOAD FORMAT
        // Use cleaner format that's easier for n8n to parse
        const payload = {
            messages: [{
                from: customerPhone,
                text: {
                    body: `ORDER_NOTIFICATION:${JSON.stringify({
                        orderId: orderData.orderId,
                        customerName: orderData.customerName || 'Valued Customer',
                        customerPhone: customerPhone,
                        customerEmail: orderData.customerEmail || 'Not provided',
                        items: orderData.items.map(item => ({
                            name: item.name,
                            quantity: item.quantity,
                            price: item.price,
                            productId: item.productId,
                            variations: item.variations || null,
                            category: item.category || null,
                            subtotal: (item.quantity * item.price).toFixed(2)
                        })),
                        total: parseFloat(orderData.total),
                        deliveryAddress: orderData.deliveryAddress,
                        deliveryMethod: orderData.deliveryMethod,
                        driver: orderData.driver,
                        isUrgent: orderData.isUrgent,
                        isPaid: orderData.isPaid,
                        orderDate: orderData.orderDate,
                        paymentStatus: orderData.paymentStatus || 'pending',
                        orderStatus: orderData.orderStatus || 'awaiting_confirmation'
                    })}`
                }
            }],
            // Add metadata for debugging
            _metadata: {
                source: 'website_cart',
                timestamp: new Date().toISOString(),
                customerSource: 'supabase_customers_table',
                retryAttempt: retryCount + 1
            }
        };

        console.log('üì§ Sending payload to:', N8N_WEBHOOK_URL);
        console.log('üìä Payload size:', JSON.stringify(payload).length, 'characters');

        // ENHANCED FETCH WITH TIMEOUT
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

        const response = await fetch(N8N_WEBHOOK_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'User-Agent': 'AutoLab-Website/1.0'
            },
            body: JSON.stringify(payload),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        console.log('üì• Response status:', response.status);
        console.log('üì• Response headers:', Object.fromEntries(response.headers.entries()));

        // Get response text for debugging
        let responseText = '';
        try {
            responseText = await response.text();
            console.log('üì• Response body:', responseText);
        } catch (textError) {
            console.log('üì• Could not read response body:', textError.message);
        }

        if (response.ok) {
            console.log('‚úÖ n8n webhook called successfully!');
            
            // Log success metrics
            console.log('üìä Success metrics:', {
                orderId: orderData.orderId,
                customerPhone: customerPhone,
                totalAmount: orderData.total,
                itemCount: orderData.items.length,
                attempt: retryCount + 1,
                responseTime: 'success'
            });
            
            return true;
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText} - ${responseText}`);
        }

    } catch (error) {
        console.error(`‚ùå n8n webhook attempt ${retryCount + 1} failed:`, error);

        // Enhanced error logging
        if (error.name === 'AbortError') {
            console.error('‚è±Ô∏è Request timed out after 30 seconds');
        } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
            console.error('üåê Network error - check connectivity and n8n URL');
        } else if (error.message.includes('JSON')) {
            console.error('üìã JSON parsing error - check payload format');
        }

        // Retry logic with exponential backoff
        if (retryCount < MAX_RETRIES) {
            const delay = RETRY_DELAYS[retryCount] || 5000;
            console.log(`üîÑ Retrying in ${delay}ms... (${retryCount + 1}/${MAX_RETRIES})`);
            
            await new Promise(resolve => setTimeout(resolve, delay));
            return sendOrderToN8n(orderData, customerData, retryCount + 1);
        }

        console.error('üí• All webhook retry attempts failed');
        
        // Log failure for debugging
        console.error('üìä Failure metrics:', {
            orderId: orderData.orderId,
            customerPhone: customerPhone,
            error: error.message,
            finalAttempt: retryCount + 1,
            totalRetries: MAX_RETRIES
        });
        
        return false;
    }
}

// UTILITY FUNCTION: Standardize phone numbers
function standardizePhoneNumber(phone) {
    if (!phone || phone === 'N/A') return null;
    
    // Remove all non-digits
    let cleanPhone = phone.toString().replace(/\D/g, '');
    
    // Handle Malaysian numbers specifically
    if (cleanPhone.startsWith('60')) {
        // Already has country code
        return '+' + cleanPhone;
    } else if (cleanPhone.startsWith('0')) {
        // Malaysian number with leading 0 - replace with country code
        return '+60' + cleanPhone.substring(1);
    } else if (cleanPhone.length >= 9 && cleanPhone.length <= 11) {
        // Assume Malaysian number without country code
        return '+60' + cleanPhone;
    }
    
    // Default: add + if missing
    return phone.startsWith('+') ? phone : '+' + cleanPhone;
}

// ENHANCED CONNECTION TEST FUNCTION
async function testN8nConnection() {
    try {
        console.log('üß™ Testing n8n webhook connectivity...');
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const testResponse = await fetch(N8N_WEBHOOK_URL, {
            method: 'GET',
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        console.log('üß™ Test response status:', testResponse.status);
        
        if (testResponse.status === 404) {
            console.error('‚ùå Webhook endpoint not found - check n8n workflow is activated');
            return false;
        } else if (testResponse.status === 405) {
            console.log('‚úÖ Webhook endpoint exists (405 Method Not Allowed is expected for GET)');
            return true;
        } else if (testResponse.status >= 200 && testResponse.status < 300) {
            console.log('‚úÖ Webhook endpoint responding normally');
            return true;
        } else {
            console.warn(`‚ö†Ô∏è Unexpected response: ${testResponse.status}`);
            return false;
        }
        
    } catch (error) {
        if (error.name === 'AbortError') {
            console.error('‚ùå Connection test timed out - n8n may be unreachable');
        } else {
            console.error('‚ùå Cannot reach n8n webhook:', error.message);
        }
        console.error('üîç Check: 1) n8n is running, 2) workflow is activated, 3) URL is correct');
        return false;
    }
}

        // Global variables
        let cartItems = [];
        let products = {};
        let subtotal = 0;
        let total = 0;

        // DOM Elements
        let emptyCartState;
        let cartItemsList;
        let cartItemsContainer;
        let cartCountElem;
        let subtotalElem;
        let totalElem;
        let checkoutBtn;

        // Initialize page on DOM content loaded
        document.addEventListener('DOMContentLoaded', async function () {
            console.log("Initializing cart page");

            // Test n8n connection on page load (optional - comment out in production)
            await testN8nConnection();

            // Initialize DOM element references
            emptyCartState = document.getElementById('emptyCartState');
            cartItemsList = document.getElementById('cartItemsList');
            cartItemsContainer = document.getElementById('cartItemsContainer');
            cartCountElem = document.getElementById('cartCount');
            subtotalElem = document.getElementById('subtotalAmount');
            totalElem = document.getElementById('totalAmount');
            checkoutBtn = document.getElementById('checkoutBtn');

            console.log("DOM elements initialized");

            const cartContainer = document.querySelector('.cart-container');

            // Create animated link
            const viewOrdersLink = document.createElement('div');
            viewOrdersLink.style.textAlign = 'center';
            viewOrdersLink.style.marginTop = '20px';
            viewOrdersLink.style.padding = '10px';
            viewOrdersLink.innerHTML = 'Click to view <a href="myorder.html" style="display: inline-block; color: #e21b1b; font-weight: bold; text-decoration: none; border-bottom: 2px solid #e21b1b; transition: all 0.3s ease; animation: colorPulse 2s infinite;">My Orders</a>';

            // Add link after cart container
            cartContainer.parentNode.insertBefore(viewOrdersLink, cartContainer.nextSibling);

            // Add animation style
            const animationStyle = document.createElement('style');
            animationStyle.textContent = `
        @keyframes colorPulse {
            0% { color: #e21b1b; }
            50% { color: #ff6b6b; }
            100% { color: #e21b1b; }
        }
    `;
            document.head.appendChild(animationStyle);
            // Check user authentication
            const userStr = localStorage.getItem('currentUser');
            if (userStr) {
                console.log("User found in session storage");
                const user = JSON.parse(userStr);
                updateUIForLoggedInUser(user);

                // Load cart data
                await loadCartItems(user.id);
            } else {
                console.log("User not in session storage, checking with Supabase");
                // If not in session, check with Supabase
                const { data: { user } } = await supabase.auth.getUser();
                if (user) {
                    console.log("User authenticated with Supabase:", user.id);
                    // User is logged in but session data is missing
                    // Get customer details from database
                    const { data: customer, error } = await supabase
                        .from('customers')
                        .select('*')
                        .eq('id', user.id)
                        .single();

                    if (!error && customer) {
                        console.log("Customer details retrieved:", customer);
                        // Store in session storage
                        localStorage.setItem('currentUser', JSON.stringify(customer));
                        updateUIForLoggedInUser(customer);

                        // Load cart data
                        await loadCartItems(customer.id);
                    } else {
                        console.log("Customer not found or error:", error);
                        // Not found or error, redirect to login
                        window.location.href = "customer-login.html";
                    }
                } else {
                    console.log("User not authenticated, redirecting to login");
                    // Not logged in, redirect to login
                    window.location.href = "customer-login.html";
                }
            }

            // Set up event listeners
            setupEventListeners();
            console.log("Cart page initialization complete");
        });

 async function loadCartItems(userId) {
    try {
        console.log("Loading cart for user:", userId);

        // First, get cart items with just the IDs
        const { data: cart, error: cartError } = await supabase
            .from('cart')
            .select('id, product_id, variant_id, quantity')
            .eq('customer_id', userId);

        if (cartError) {
            console.error('Error loading cart:', cartError);
            return;
        }

        if (!cart || cart.length === 0) {
            console.log("Cart is empty");
            showEmptyCartState();
            return;
        }

        console.log("Cart items retrieved:", cart);

        // Get unique product IDs and variant IDs
        const productIds = [...new Set(cart.map(item => item.product_id))];
        const variantIds = [...new Set(cart.map(item => item.variant_id).filter(id => id))];

        console.log("Product IDs to fetch:", productIds);
        console.log("Variant IDs to fetch:", variantIds);

        // Fetch product details with proper schema
        const { data: productData, error: productError } = await supabase
            .from('products')
            .select(`
                id,
                product_id,
                name,
                category,
                brand,
                brand_id,
                image_url,
                description,
                model,
                year,
                screensize,
                brands (id, name, code)
            `)
            .in('id', productIds);

        if (productError) {
            console.error('Error loading product details:', productError);
            
            // Fallback: try without foreign key relationships
            console.log("Trying fallback query without foreign key relationships...");
            const { data: fallbackProductData, error: fallbackError } = await supabase
                .from('products')
                .select(`
                    id,
                    product_id,
                    name,
                    category,
                    brand,
                    brand_id,
                    image_url,
                    description,
                    model,
                    year,
                    screensize
                `)
                .in('id', productIds);

            if (fallbackError) {
                console.error('Fallback product query also failed:', fallbackError);
                return;
            }

            // For fallback, we'll fetch brands and categories separately
            const brandIds = [...new Set(fallbackProductData.map(p => p.brand_id).filter(id => id))];
            const categoryIds = [...new Set(fallbackProductData.map(p => p.category_id).filter(id => id))];

            let brandsData = [];
            let categoriesData = [];

            if (brandIds.length > 0) {
                const { data: brands } = await supabase
                    .from('brands')
                    .select('id, name')
                    .in('id', brandIds);
                brandsData = brands || [];
            }

            if (categoryIds.length > 0) {
                const { data: categories } = await supabase
                    .from('categories')
                    .select('id, name')
                    .in('id', categoryIds);
                categoriesData = categories || [];
            }

            // Create lookup objects
            const brandsLookup = {};
            brandsData.forEach(brand => {
                brandsLookup[brand.id] = brand;
            });

            const categoriesLookup = {};
            categoriesData.forEach(category => {
                categoriesLookup[category.id] = category;
            });

            // Enhance product data with brand and category names
            fallbackProductData.forEach(product => {
                product.brands = brandsLookup[product.brand_id] || null;
                product.categories = categoriesLookup[product.category_id] || null;
            });

            productData = fallbackProductData;
            console.log("Fallback product data retrieved:", productData);
        } else {
            console.log("Product data retrieved:", productData);
        }

        // Fetch variant details
        let variantData = [];
        if (variantIds.length > 0) {
            const { data: variants, error: variantError } = await supabase
                .from('product_variants')
                .select(`
                    id,
                    variant_name,
                    variant_sku,
                    variant_type,
                    available_stock,
                    variant_components (
                        quantity,
                        components (
                            id,
                            sku,
                            name,
                            type,
                            retail_price,
                            wholesale_price
                        )
                    )
                `)
                .in('id', variantIds);

            if (variantError) {
                console.error('Error loading variant details:', variantError);
            } else {
                variantData = variants || [];
                console.log("Variant data retrieved:", variantData);
            }
        }

        // Create lookup objects for products and variants
        const products = {};
        productData.forEach(product => {
            products[product.id] = product;
        });

        const variants = {};
        variantData.forEach(variant => {
            variants[variant.id] = variant;
        });

        // Get current user's merchant status for pricing
        const userStr = localStorage.getItem('currentUser');
        let isMerchant = false;
        if (userStr) {
            const user = JSON.parse(userStr);
            isMerchant = user.status === 'merchant';
        }

        // Map cart items with product details and merchant pricing
        cartItems = cart.map(item => {
            const product = products[item.product_id];
            const variant = variants[item.variant_id];
            
            if (!product) {
                console.warn(`Product not found for ID: ${item.product_id}`);
                return null;
            }

            if (!variant) {
                console.warn(`Variant not found for cart item ID: ${item.id}, variant_id: ${item.variant_id}`);
                return null;
            }

            // Calculate price from components
            let retailPrice = 0;
            let wholesalePrice = 0;
            
            if (variant.variant_components && variant.variant_components.length > 0) {
                variant.variant_components.forEach(vc => {
                    const component = vc.components;
                    if (component) {
                        const quantity = vc.quantity || 1;
                        retailPrice += (component.retail_price || 0) * quantity;
                        wholesalePrice += (component.wholesale_price || 0) * quantity;
                    }
                });
            }
            
            // Determine display price based on user status
            let displayPrice = retailPrice;
            let isMerchantPrice = false;
            
            if (isMerchant && wholesalePrice > 0) {
                displayPrice = wholesalePrice;
                isMerchantPrice = true;
            }

            // Build product name with variant
            const productName = `${product.name} - ${variant.variant_name}`;
            const brandName = product.brands?.name || 'Unknown Brand';

            const productWithPricing = {
                ...product,
                name: productName,
                product_id: variant.variant_sku, // Show variant SKU instead of parent product ID
                price: displayPrice,
                originalPrice: retailPrice,
                wholesale_price: wholesalePrice,
                isMerchantPrice: isMerchantPrice,
                availableStock: variant.available_stock,
                brand: brandName,
                category: product.categories?.name || 'Unknown Category',
                variant: variant
            };

            return {
                id: item.id,
                productId: item.product_id,
                variantId: item.variant_id,
                quantity: item.quantity,
                product: productWithPricing
            };
        }).filter(item => item !== null); // Remove any null items

        console.log(isMerchant ? '‚úÖ Merchant customer detected - cart showing wholesale prices' : '‚úÖ Regular customer - cart showing retail prices');
        console.log("Mapped cart items:", cartItems);

        // Update cart display
        updateCartDisplay();

    } catch (error) {
        console.error('Error loading cart:', error);
    }
}

        // Show empty cart state
        function showEmptyCartState() {
            if (emptyCartState) emptyCartState.style.display = 'flex';
            if (cartItemsList) cartItemsList.style.display = 'none';

            const orderSummary = document.getElementById('orderSummary');
            if (orderSummary) orderSummary.style.opacity = '0.5';

            if (checkoutBtn) checkoutBtn.disabled = true;
        }

        // Show cart items state
        function showCartItemsState() {
            if (emptyCartState) emptyCartState.style.display = 'none';
            if (cartItemsList) cartItemsList.style.display = 'block';

            const orderSummary = document.getElementById('orderSummary');
            if (orderSummary) orderSummary.style.opacity = '1';

            if (checkoutBtn) checkoutBtn.disabled = false;
        }

        // Update cart display
        function updateCartDisplay() {
            // Update cart count in header
            const totalItems = cartItems.reduce((total, item) => total + item.quantity, 0);
            if (cartCountElem) cartCountElem.textContent = totalItems;

            if (cartItems.length === 0) {
                showEmptyCartState();
                return;
            }

            // Show cart items
            showCartItemsState();

            // Clear and regenerate cart items
            if (cartItemsContainer) cartItemsContainer.innerHTML = '';

            // Calculate subtotal
            subtotal = 0;

            cartItems.forEach(item => {
                if (!item.product) return;

                const itemSubtotal = item.quantity * item.product.price;
                subtotal += itemSubtotal;

                const cartItemElement = document.createElement('div');
                cartItemElement.className = 'cart-item';

                cartItemElement.innerHTML = `
            <div style="display: flex; align-items: center; margin-right: 15px;">
                <input type="checkbox" id="select-item-${item.id}" class="item-checkbox" checked>
            </div>
           <div class="cart-item-image">
    ${item.product.image_url ?
                        `<img src="${item.product.image_url}" alt="${item.product.name}" style="max-width: 100%; max-height: 100%; object-fit: contain;">` :
                        `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none"
            stroke="#999" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="6"></circle>
            <circle cx="12" cy="12" r="2"></circle>
        </svg>`
                    }
</div>
            <div class="cart-item-details">
                <div class="cart-item-name">${item.product.name}</div>
                <div class="cart-item-sku">${item.product.product_id}</div>
                <div class="cart-item-price">
                    RM ${item.product.price.toFixed(2)}
                    ${item.product.isMerchantPrice ? '<span style="color: var(--secondary-600); font-size: 12px; display: block;">(B2B Price)</span>' : ''}
                </div>
            </div>
            <div class="cart-item-actions">
                <div class="quantity-control">
                    <button class="quantity-btn minus-btn" data-id="${item.id}">-</button>
                    <input type="number" class="quantity-input" value="${item.quantity}" min="1" data-id="${item.id}">
                    <button class="quantity-btn plus-btn" data-id="${item.id}">+</button>
                </div>
                <div class="remove-item" data-id="${item.id}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                    </svg>
                </div>
            </div>
        `;

                if (cartItemsContainer) cartItemsContainer.appendChild(cartItemElement);
            });

            // Update summary
            total = subtotal;
            if (subtotalElem) subtotalElem.textContent = `RM ${subtotal.toFixed(2)}`;
            if (totalElem) totalElem.textContent = `RM ${total.toFixed(2)}`;

            // Add event listeners for cart item actions
            setupCartItemEvents();

            // Add listeners for checkboxes
            setupCheckboxListeners();

            // Initially calculate selected items total
            updateSelectedTotal();
        }

        // Setup checkbox listeners
        function setupCheckboxListeners() {
            // Select all checkbox
            const selectAllCheckbox = document.getElementById('select-all-items');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function () {
                    const isChecked = this.checked;
                    document.querySelectorAll('.item-checkbox').forEach(checkbox => {
                        checkbox.checked = isChecked;
                    });
                    updateSelectedTotal();
                });
            }

            // Individual item checkboxes
            document.querySelectorAll('.item-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function () {
                    updateSelectedTotal();

                    // Check if all items are selected
                    const allItems = Array.from(document.querySelectorAll('.item-checkbox'));
                    if (allItems.length > 0) {
                        const allChecked = allItems.every(cb => cb.checked);
                        const selectAllCheckbox = document.getElementById('select-all-items');
                        if (selectAllCheckbox) selectAllCheckbox.checked = allChecked;
                    }
                });
            });
        }

        // Update selected items total
        function updateSelectedTotal() {
            const selectedTotal = cartItems.reduce((sum, item) => {
                const checkbox = document.getElementById(`select-item-${item.id}`);
                if (checkbox && checkbox.checked) {
                    return sum + (item.quantity * item.product.price);
                }
                return sum;
            }, 0);

            const selectedItemsTotalElem = document.getElementById('selectedItemsTotal');

            if (!selectedItemsTotalElem || !checkoutBtn) return;

            // Show the selected total only if it's different from the cart total
            if (selectedTotal < subtotal) {
                selectedItemsTotalElem.style.display = 'block';
                selectedItemsTotalElem.textContent = `Selected: RM ${selectedTotal.toFixed(2)}`;
                // Enable checkout button if at least one item is selected
                checkoutBtn.disabled = selectedTotal === 0;
            } else {
                selectedItemsTotalElem.style.display = 'none';
                // Enable checkout button if cart has items
                checkoutBtn.disabled = cartItems.length === 0;
            }
        }

        // Set up event listeners for cart item actions
        function setupCartItemEvents() {
            // Quantity buttons
            document.querySelectorAll('.minus-btn').forEach(btn => {
                btn.addEventListener('click', async function () {
                    const id = this.getAttribute('data-id');
                    const item = cartItems.find(item => item.id === id);
                    if (item && item.quantity > 1) {
                        await updateCartItemQuantity(id, item.quantity - 1);
                    }
                });
            });

            document.querySelectorAll('.plus-btn').forEach(btn => {
                btn.addEventListener('click', async function () {
                    const id = this.getAttribute('data-id');
                    const item = cartItems.find(item => item.id === id);
                    if (item) {
                        await updateCartItemQuantity(id, item.quantity + 1);
                    }
                });
            });

            // Quantity input changes
            document.querySelectorAll('.quantity-input').forEach(input => {
                input.addEventListener('change', async function () {
                    const id = this.getAttribute('data-id');
                    const newQuantity = parseInt(this.value);
                    if (newQuantity > 0) {
                        await updateCartItemQuantity(id, newQuantity);
                    } else {
                        this.value = 1;
                        await updateCartItemQuantity(id, 1);
                    }
                });
            });

            // Remove item buttons
            document.querySelectorAll('.remove-item').forEach(btn => {
                btn.addEventListener('click', async function () {
                    const id = this.getAttribute('data-id');
                    await removeCartItem(id);
                });
            });
        }

        // Update cart item quantity
        async function updateCartItemQuantity(itemId, newQuantity) {
            try {
                const { error } = await supabase
                    .from('cart')
                    .update({ quantity: newQuantity })
                    .eq('id', itemId);

                if (error) {
                    console.error('Error updating cart item:', error);
                    return;
                }

                // Update local cart items
                const index = cartItems.findIndex(item => item.id === itemId);
                if (index !== -1) {
                    cartItems[index].quantity = newQuantity;
                    updateCartDisplay();
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }

        // Remove cart item
        async function removeCartItem(itemId) {
            try {
                const { error } = await supabase
                    .from('cart')
                    .delete()
                    .eq('id', itemId);

                if (error) {
                    console.error('Error removing cart item:', error);
                    return;
                }

                // Remove from local cart items
                cartItems = cartItems.filter(item => item.id !== itemId);
                updateCartDisplay();
            } catch (error) {
                console.error('Error:', error);
            }
        }

        // Update UI for logged-in user
        function updateUIForLoggedInUser(user) {
    const initials = user.name ? user.name.charAt(0) : 'C';
    document.getElementById('userAvatar').textContent = initials;
    document.getElementById('userName').textContent = user.name || 'Customer';

            // Update user name
            const userName = document.getElementById('userName');
            if (userName) {
                userName.textContent = user.name || 'Customer';
            }

            // Update user status display
            const userStatusElement = document.querySelector('.user-info > div:nth-child(2) > div:last-child');
    if (userStatusElement) {
        if (user.status === 'merchant') {
            userStatusElement.innerHTML = '<span style="color: var(--secondary-600); font-weight: 600;">Merchant Customer</span>';
        } else {
            userStatusElement.textContent = 'Customer';
        }
    }

            // Refresh cart pricing when user status changes
            refreshCartPricing();

            // Set up event listeners for dropdown
            if (userAvatar) {
                userAvatar.addEventListener('click', toggleDropdown);
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', function (e) {
                const dropdown = document.getElementById('userDropdown');
                const avatar = document.getElementById('userAvatar');

                if (dropdown && avatar && !avatar.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.remove('active');
                }
            });

            // Handle logout
            const logoutButton = document.getElementById('logoutButton');
            if (logoutButton) {
                logoutButton.addEventListener('click', logout);
            }
        }

        // Updated refresh cart pricing function
async function refreshCartPricing() {
    if (!cartItems || cartItems.length === 0) return;

    // Get current user's status
    const userStr = localStorage.getItem('currentUser');
    let isMerchant = false;
    if (userStr) {
        const user = JSON.parse(userStr);
        isMerchant = user.status === 'merchant';
    }

    // Update each cart item's product pricing based on new schema
    cartItems = cartItems.map(item => {
        if (!item.product || !item.product.variant) return item;

        const variant = item.product.variant;
        
        // Calculate price from components
        let retailPrice = 0;
        let wholesalePrice = 0;
        
        if (variant.variant_components && variant.variant_components.length > 0) {
            variant.variant_components.forEach(vc => {
                const component = vc.components;
                if (component) {
                    const quantity = vc.quantity || 1;
                    retailPrice += (component.retail_price || 0) * quantity;
                    wholesalePrice += (component.wholesale_price || 0) * quantity;
                }
            });
        }
        
        let displayPrice = retailPrice;
        let isMerchantPrice = false;
        
        if (isMerchant && wholesalePrice > 0) {
            displayPrice = wholesalePrice;
            isMerchantPrice = true;
        }
        
        return {
            ...item,
            product: {
                ...item.product,
                price: displayPrice,
                isMerchantPrice: isMerchantPrice
            }
        };
    });

    // Re-render cart display with updated pricing
    updateCartDisplay();

    if (isMerchant) {
        console.log('‚úÖ Cart pricing updated for Merchant customer - showing wholesale prices');
    } else {
        console.log('‚úÖ Cart pricing updated for regular customer - showing retail prices');
    }
}

// Updated loadCartCount function for new schema
async function loadCartCount() {
    try {
        const userStr = localStorage.getItem('currentUser');
        if (!userStr) return;
        
        const user = JSON.parse(userStr);
        const { data, error } = await supabase
            .from('cart')
            .select('quantity')
            .eq('customer_id', user.id);
        
        if (error) {
            console.error('Error loading cart count:', error);
            return;
        }
        
        const totalItems = data.reduce((total, item) => total + item.quantity, 0);
        const cartCountElem = document.getElementById('cartCount');
        if (cartCountElem) {
            cartCountElem.textContent = totalItems;
        }
        
        // Also update cart count in header if it exists
        const headerCartCount = document.querySelector('.cart-count');
        if (headerCartCount) {
            headerCartCount.textContent = totalItems;
        }
        
    } catch (error) {
        console.error('Error loading cart count:', error);
    }
}

        // Toggle dropdown menu
        function toggleDropdown() {
            const dropdown = document.getElementById('userDropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Checkout button
            if (checkoutBtn) {
                checkoutBtn.addEventListener('click', function () {
                    proceedToCheckout();
                });
            }
        }

// Enhanced proceedToCheckout function with stock deduction
// ============================================
// COMPLETE PROCEEDTOCHECKOUT FUNCTION
// With proper component-based stock management
// ============================================

// REPLACE your entire proceedToCheckout function with this complete version
async function proceedToCheckout() {
    try {
        console.log('üõí Starting checkout process...');
        
        // Get current user
        const userStr = localStorage.getItem('currentUser');
        if (!userStr) {
            alert('Please log in to proceed with checkout');
            return;
        }

        const user = JSON.parse(userStr);
        console.log('üë§ User:', user.id);

        // Check if cart has items
        if (cartItems.length === 0) {
            alert('Your cart is empty');
            return;
        }

        // Check which items are selected for checkout
        const selectedItems = cartItems.filter(item => {
            const checkbox = document.getElementById(`select-item-${item.id}`);
            return checkbox && checkbox.checked;
        });

        console.log('üì¶ Selected items:', selectedItems.length);

        if (selectedItems.length === 0) {
            alert('Please select at least one item to checkout');
            return;
        }

        // STEP 1: Validate stock availability before proceeding
        console.log('üìä Validating stock availability from shared component inventory...');
        const stockValidationResults = await validateAndReserveStock(selectedItems, false); // false = just validate, don't deduct yet
        
        if (!stockValidationResults.success) {
            alert(`‚ùå Stock validation failed:\n\n${stockValidationResults.errors.join('\n')}\n\nPlease update your cart and try again.`);
            // Refresh cart to show updated stock levels
            await loadCartItems(user.id);
            return;
        }

        // Calculate selected items total
        const selectedTotal = selectedItems.reduce((sum, item) => {
            return sum + (item.quantity * item.product.price);
        }, 0);

        console.log('üí∞ Selected total:', selectedTotal);

        // Show checkout dialog
        const checkoutData = await showCombinedCheckoutDialog(user, selectedTotal);
        if (!checkoutData) return; // User cancelled

        // Confirm order placement
        if (!confirm("Are you sure you want to place this order? Stock will be deducted from shared component inventory.")) {
            return;
        }

        console.log('‚úÖ User confirmed order');

        // STEP 2: Deduct stock from components (this time for real)
        console.log('üìä Deducting stock from shared component inventory...');
        const stockDeductionResults = await validateAndReserveStock(selectedItems, true); // true = actually deduct stock
        
        if (!stockDeductionResults.success) {
            alert(`‚ùå Stock deduction failed:\n\n${stockDeductionResults.errors.join('\n')}\n\nSomeone else may have purchased these items. Please refresh and try again.`);
            await loadCartItems(user.id);
            return;
        }

        console.log('‚úÖ Stock deducted successfully from shared components');
        
        // Check how this affects other products using shared components
        const sharedComponents = stockDeductionResults.reservedComponents.filter(c => 
            c.componentSku.startsWith('CB-') || c.componentSku.startsWith('LHL-')
        );
        
        if (sharedComponents.length > 0) {
            console.log('üîó Shared components affected:');
            for (const component of sharedComponents) {
                console.log(`  - ${component.componentSku}: ${component.previousCurrentStock} ‚Üí ${component.newCurrentStock}`);
                // All products using this component are automatically updated
            }
        }

        // Get fresh customer data from database
        const { data: freshCustomerData, error: customerFetchError } = await supabase
            .from('customers')
            .select('phone, name, email, customer_id')
            .eq('id', user.id)
            .single();

        if (customerFetchError) {
            console.error('Error fetching customer data:', customerFetchError);
        }

        const customerDataForN8n = freshCustomerData || user;

        // Generate order ID
        const currentYear = new Date().getFullYear();
        const randomNum = Math.floor(1000 + Math.random() * 9000);
        const orderIdValue = `ORD-${currentYear}-${randomNum}`;

        console.log('üè∑Ô∏è Generated Order ID:', orderIdValue);

        // STEP 3: Create order and order items (wrapped in try-catch for rollback)
        let orderUUID = null;
        try {
            console.log('üíæ Creating order in database...');
            
            const { data: order, error: orderError } = await supabase
                .from('orders')
                .insert({
                    customer_id: user.id,
                    amount: checkoutData.finalAmount,
                    status: 'awaiting_confirmation',
                    payment_status: 'unpaid',
                    address: checkoutData.deliveryAddress,
                    order_date: new Date().toISOString(),
                    order_id: orderIdValue,
                    driver: checkoutData.driver,
                    is_urgent: checkoutData.isUrgent,
                    customer_phone: customerDataForN8n.phone || user.phone || 'N/A'
                })
                .select();

            if (orderError) {
                throw new Error('Failed to create order: ' + orderError.message);
            }

            orderUUID = order[0].id;
            console.log('‚úÖ Order created with UUID:', orderUUID);

            // Create order items with component tracking
            console.log('üìù Creating order items with component tracking...');
            
            const orderItems = [];
            
            for (const item of selectedItems) {
                console.log(`Processing item: ${item.product.name} (Variant ID: ${item.variantId})`);
                
                // Get components for this variant for tracking
                const { data: variantComponents } = await supabase
                    .from('variant_components')
                    .select('component_id, quantity, components(sku, name)')
                    .eq('variant_id', item.variantId);
                
                const componentsList = variantComponents?.map(vc => ({
                    sku: vc.components.sku,
                    name: vc.components.name,
                    quantity: vc.quantity * item.quantity
                })) || [];
                
                const orderItem = {
                    order_id: orderUUID,
                    product_id: item.productId,
                    quantity: item.quantity,
                    unit_price: item.product.price,
                    variations: item.product.variant?.variant_name || null,
                    category: item.product.category || null,
                    variant_id: item.variantId, // Store variant ID for tracking
                    reserved_stock: item.quantity // Track how much stock was deducted
                };

                orderItems.push(orderItem);
                console.log('‚úÖ Prepared order item with components:', orderItem);
            }

            console.log(`üíæ Inserting ${orderItems.length} order items...`);

            const { data: insertedItems, error: itemsError } = await supabase
                .from('order_products')
                .insert(orderItems)
                .select();

            if (itemsError) {
                throw new Error('Failed to insert order items: ' + itemsError.message);
            }

            console.log('‚úÖ Order items inserted successfully:', insertedItems);

            // STEP 4: Send WhatsApp notification
            const orderDataForN8n = {
                orderId: orderIdValue,
                customerName: customerDataForN8n.name || user.name || 'Customer',
                customerPhone: customerDataForN8n.phone || user.phone || 'N/A',
                customerEmail: customerDataForN8n.email || user.email || 'Not provided',
                items: selectedItems.map(item => ({
                    name: item.product.name,
                    quantity: item.quantity,
                    price: item.product.price,
                    productId: item.product.product_id || item.product.id,
                    variantId: item.variantId,
                    variations: item.product.variant?.variant_name || null,
                    category: item.product.category || null,
                    subtotal: (item.quantity * item.product.price).toFixed(2)
                })),
                total: checkoutData.finalAmount,
                deliveryAddress: checkoutData.deliveryAddress,
                deliveryMethod: checkoutData.deliveryMethod,
                driver: checkoutData.driver,
                isUrgent: checkoutData.isUrgent,
                isPaid: false,
                orderDate: new Date().toISOString(),
                paymentStatus: 'pending',
                orderStatus: 'awaiting_confirmation',
                // Add component details for admin visibility
                componentsDeducted: stockDeductionResults.reservedComponents.map(c => ({
                    sku: c.componentSku,
                    name: c.componentName,
                    deductedQuantity: c.deductedQuantity,
                    newCurrentStock: c.newCurrentStock,
                    newAvailableStock: c.newAvailableStock,
                    affectedVariants: c.affectedVariants.map(v => v.itemName)
                }))
            };

            console.log('üöÄ Sending purchase notification to n8n...');
            const n8nSuccess = await sendOrderToN8n(orderDataForN8n, customerDataForN8n);

            if (!n8nSuccess) {
                console.warn('‚ö†Ô∏è Failed to send WhatsApp notification, but order was placed successfully');
            }

            // STEP 5: Clean up cart and show success
            console.log('üßπ Cleaning up cart...');
            
            for (const item of selectedItems) {
                const { error: removeError } = await supabase
                    .from('cart')
                    .delete()
                    .eq('id', item.id);

                if (removeError) {
                    console.error('Error removing cart item:', removeError);
                } else {
                    console.log('‚úÖ Removed cart item:', item.id);
                }
            }

            // Update local cart items
            cartItems = cartItems.filter(item => {
                const checkbox = document.getElementById(`select-item-${item.id}`);
                return !(checkbox && checkbox.checked);
            });

            // Update cart display
            updateCartDisplay();

            // Show success message with component deduction details
            showOrderSuccessMessage(
                orderIdValue, 
                checkoutData, 
                selectedTotal, 
                n8nSuccess, 
                stockDeductionResults.reservedComponents
            );

            console.log('‚úÖ Checkout process completed successfully!');
            console.log('üìä Shared component inventory updated - all related products now show updated stock');

        } catch (error) {
            console.error('‚ùå Error during order creation, attempting rollback...');
            
            // ROLLBACK: Restore deducted component stock if order creation failed
            if (stockDeductionResults.reservedComponents && stockDeductionResults.reservedComponents.length > 0) {
                console.log('üîÑ Rolling back component stock deductions...');
                await rollbackComponentDeductions(stockDeductionResults.reservedComponents);
            }
            
            // ROLLBACK: Delete order if it was created but items failed
            if (orderUUID) {
                await supabase.from('orders').delete().eq('id', orderUUID);
                console.log('üóëÔ∏è Rolled back order creation');
            }
            
            throw error; // Re-throw to be caught by outer try-catch
        }

    } catch (error) {
        console.error('üí• Error processing checkout:', error);
        console.error('üí• Full error details:', error.message, error.stack);
        alert('An error occurred during checkout. Please try again. Error: ' + error.message);
    }
}

// ============================================
// HELPER FUNCTION (Add this if not already present)
// ============================================

async function checkComponentStockAcrossProducts(componentSku) {
    console.log(`üîç Checking how component ${componentSku} affects multiple products...`);
    
    try {
        // Get the component
        const { data: component, error: compError } = await supabase
            .from('components')
            .select('id, sku, name, available_stock')
            .eq('sku', componentSku)
            .single();
        
        if (compError || !component) {
            console.error('Component not found:', componentSku);
            return;
        }
        
        // Find all variants using this component
        const { data: variantComponents, error: vcError } = await supabase
            .from('variant_components')
            .select(`
                variant_id,
                quantity,
                product_variants (
                    id,
                    variant_name,
                    variant_sku,
                    products (
                        name,
                        model,
                        brand_id
                    )
                )
            `)
            .eq('component_id', component.id);
        
        if (vcError) {
            console.error('Error finding variants:', vcError);
            return;
        }
        
        console.log(`üìä Component ${componentSku} stock: ${component.available_stock} units`);
        console.log(`üîó Used by ${variantComponents.length} product variants:`);
        
        variantComponents.forEach(vc => {
            const variant = vc.product_variants;
            const product = variant?.products;
            if (product) {
                console.log(`  - ${product.name} (${variant.variant_name}): Uses ${vc.quantity} unit(s) per item`);
            }
        });
        
        return {
            component,
            affectedVariants: variantComponents
        };
        
    } catch (error) {
        console.error('Error checking component stock:', error);
    }
}

// REPLACE validateAndReserveStock function in your cart.html
async function validateAndReserveStock(selectedItems, actuallyDeduct = false) {
    console.log(`üìä ${actuallyDeduct ? 'Deducting from' : 'Validating'} shared component inventory for ${selectedItems.length} items...`);
    
    const results = {
        success: true,
        errors: [],
        reservedComponents: []
    };

    // Group items by components to calculate total requirements
    const componentRequirements = new Map();

    // First pass: Calculate total requirements for each component
    for (const item of selectedItems) {
        try {
            if (!item.variantId) {
                console.error('‚ùå Missing variant ID for item:', item);
                results.errors.push(`‚ùå ${item.product.name}: No variant ID found`);
                results.success = false;
                continue;
            }

            console.log(`üîç Getting components for variant: ${item.product.name} (${item.variantId})`);

            // Get components for this variant
            const { data: variantComponents, error: vcError } = await supabase
                .from('variant_components')
                .select(`
                    component_id,
                    quantity,
                    components (
                        id,
                        sku,
                        name,
                        current_stock,
                        reserved_stock,
                        available_stock
                    )
                `)
                .eq('variant_id', item.variantId);

            if (vcError) {
                console.error('‚ùå Error getting variant components:', vcError);
                results.errors.push(`‚ùå ${item.product.name}: Unable to get components - ${vcError.message}`);
                results.success = false;
                continue;
            }

            if (!variantComponents || variantComponents.length === 0) {
                console.error('‚ùå No components found for variant:', item.variantId);
                results.errors.push(`‚ùå ${item.product.name}: No components linked to this variant`);
                results.success = false;
                continue;
            }

            console.log(`üì¶ Found ${variantComponents.length} components for ${item.product.name}`);

            // Add each component requirement to the map
            for (const vc of variantComponents) {
                const component = vc.components;
                if (!component) {
                    console.error('‚ùå Component data missing');
                    continue;
                }

                const componentId = component.id;
                const requiredQty = vc.quantity * item.quantity;

                if (componentRequirements.has(componentId)) {
                    const existing = componentRequirements.get(componentId);
                    existing.requiredQuantity += requiredQty;
                    existing.requestingItems.push({
                        itemName: item.product.name,
                        quantity: requiredQty,
                        variantId: item.variantId
                    });
                } else {
                    componentRequirements.set(componentId, {
                        componentId: componentId,
                        componentSku: component.sku,
                        componentName: component.name,
                        currentStock: component.current_stock || 0,
                        reservedStock: component.reserved_stock || 0,
                        availableStock: component.available_stock || 0,
                        requiredQuantity: requiredQty,
                        requestingItems: [{
                            itemName: item.product.name,
                            quantity: requiredQty,
                            variantId: item.variantId
                        }]
                    });
                }
            }

        } catch (error) {
            console.error('‚ùå Unexpected error processing item:', error);
            results.errors.push(`‚ùå ${item.product.name}: ${error.message}`);
            results.success = false;
        }
    }

    if (componentRequirements.size === 0) {
        results.errors.push('‚ùå No valid components found for any selected items');
        results.success = false;
        return results;
    }

    console.log('üìä Component requirements summary:');
    componentRequirements.forEach((req, componentId) => {
        console.log(`  ${req.componentSku}: Need ${req.requiredQuantity}, Available ${req.availableStock}`);
        req.requestingItems.forEach(item => {
            console.log(`    - ${item.itemName}: ${item.quantity} units`);
        });
    });

    // Second pass: Validate stock availability
    for (const [componentId, requirement] of componentRequirements) {
        if (requirement.availableStock < requirement.requiredQuantity) {
            const itemsList = requirement.requestingItems
                .map(item => `${item.itemName} (${item.quantity} units)`)
                .join(', ');
            
            results.errors.push(
                `‚ùå Component ${requirement.componentSku} (${requirement.componentName}): ` +
                `Only ${requirement.availableStock} available, but ${requirement.requiredQuantity} needed for: ${itemsList}`
            );
            results.success = false;
        }
    }

    if (!results.success) {
        console.error('‚ùå Component stock validation failed');
        return results;
    }

    // Third pass: Actually deduct stock if requested
    if (actuallyDeduct) {
        console.log('üîÑ DEDUCTING stock from shared component inventory...');

        for (const [componentId, requirement] of componentRequirements) {
            try {
                // Deduct from current_stock (this will automatically update available_stock)
                const newCurrentStock = requirement.currentStock - requirement.requiredQuantity;
                
                console.log(`üîÑ Deducting from component ${requirement.componentSku}:`);
                console.log(`   Current Stock: ${requirement.currentStock} ‚Üí ${newCurrentStock}`);
                console.log(`   Reserved Stock: ${requirement.reservedStock} (unchanged)`);
                console.log(`   Available will become: ${newCurrentStock - requirement.reservedStock}`);

                const { data: updatedComponent, error: updateError } = await supabase
                    .from('components')
                    .update({
                        current_stock: newCurrentStock,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', componentId)
                    .eq('current_stock', requirement.currentStock) // Optimistic lock
                    .select()
                    .single();

                if (updateError || !updatedComponent) {
                    console.error('‚ùå Failed to deduct component stock:', updateError);
                    
                    // Rollback any previous deductions
                    if (results.reservedComponents.length > 0) {
                        console.log('üîÑ Rolling back previous deductions...');
                        await rollbackComponentDeductions(results.reservedComponents);
                        results.reservedComponents = [];
                    }
                    
                    results.errors.push(
                        `‚ùå Component ${requirement.componentSku}: Failed to deduct stock - ` +
                        `another order may have taken it`
                    );
                    results.success = false;
                    break;
                }

                console.log(`‚úÖ Deducted ${requirement.requiredQuantity} units from ${requirement.componentSku}`);
                console.log(`   New current stock: ${updatedComponent.current_stock}`);
                console.log(`   New available stock: ${updatedComponent.available_stock}`);
                
                // Track deduction for potential rollback
                results.reservedComponents.push({
                    componentId: componentId,
                    componentSku: requirement.componentSku,
                    componentName: requirement.componentName,
                    previousCurrentStock: requirement.currentStock,
                    newCurrentStock: updatedComponent.current_stock,
                    deductedQuantity: requirement.requiredQuantity,
                    newAvailableStock: updatedComponent.available_stock,
                    previousAvailableStock: requirement.availableStock,
                    affectedVariants: requirement.requestingItems
                });

                // Log inventory transaction
                await supabase
                    .from('inventory_transactions')
                    .insert({
                        component_id: componentId,
                        transaction_type: 'sale',
                        quantity: -requirement.requiredQuantity,
                        reference_type: 'order',
                        notes: `Sale - Items: ${requirement.requestingItems.map(i => i.itemName).join(', ')}`
                    });

                // Update all variant stocks that use this component
                console.log(`üîÑ Updating variant stocks for component ${requirement.componentSku}...`);
                await updateVariantStocksForComponent(componentId);

            } catch (error) {
                console.error('‚ùå Error deducting component stock:', error);
                
                if (results.reservedComponents.length > 0) {
                    await rollbackComponentDeductions(results.reservedComponents);
                    results.reservedComponents = [];
                }
                
                results.errors.push(`‚ùå Component ${requirement.componentSku}: ${error.message}`);
                results.success = false;
                break;
            }
        }
    }

    if (actuallyDeduct && results.success) {
        console.log(`‚úÖ Successfully deducted stock from ${results.reservedComponents.length} shared components`);
        console.log('üìä All products using these components now show updated stock levels');
    } else if (results.success) {
        console.log('‚úÖ All items have sufficient stock in shared component inventory');
    }

    return results;
}

// NEW: Function to update all variant stocks when a component stock changes
async function updateVariantStocksForComponent(componentId) {
    try {
        // Get all variants that use this component
        const { data: affectedVariants, error: variantsError } = await supabase
            .from('variant_components')
            .select('variant_id')
            .eq('component_id', componentId);

        if (variantsError || !affectedVariants) {
            console.error('Error finding affected variants:', variantsError);
            return;
        }

        // Update each variant's stock
        for (const variantComponent of affectedVariants) {
            const { error: updateError } = await supabase
                .from('product_variants')
                .update({
                    available_stock: supabase.sql`(
                        SELECT MIN(c.available_stock / vc.quantity)
                        FROM variant_components vc
                        JOIN components c ON c.id = vc.component_id
                        WHERE vc.variant_id = ${variantComponent.variant_id}
                    )`,
                    last_stock_update: new Date().toISOString()
                })
                .eq('id', variantComponent.variant_id);

            if (updateError) {
                console.error('Error updating variant stock:', updateError);
            }
        }

        console.log(`‚úÖ Updated stock for all variants using component`);

    } catch (error) {
        console.error('Error updating variant stocks:', error);
    }
}

// NEW: Rollback function for component deductions
async function rollbackComponentDeductions(deductedComponents) {
    console.log('üîÑ Rolling back component stock deductions for', deductedComponents.length, 'components...');
    
    for (const component of deductedComponents) {
        try {
            // Restore the previous current_stock
            const { error } = await supabase
                .from('components')
                .update({
                    current_stock: component.previousCurrentStock,
                    updated_at: new Date().toISOString()
                })
                .eq('id', component.componentId);

            if (error) {
                console.error(`‚ùå Failed to rollback component ${component.componentSku}:`, error);
            } else {
                console.log(`‚úÖ Rolled back component ${component.componentSku}:`);
                console.log(`   Current Stock: ${component.newCurrentStock} ‚Üí ${component.previousCurrentStock}`);
                
                // Update variant stocks for this component
                await updateVariantStocksForComponent(component.componentId);
            }

            // Log the rollback transaction
            await supabase
                .from('inventory_transactions')
                .insert({
                    component_id: component.componentId,
                    transaction_type: 'adjustment',
                    quantity: component.deductedQuantity,
                    reference_type: 'rollback',
                    notes: 'Stock rollback due to order failure'
                });

        } catch (error) {
            console.error(`Error rolling back component ${component.componentSku}:`, error);
        }
    }
}

// ADD this function to your cart.html (around line 2000)
function showStockValidationError(errorMessages) {
    console.log('üö® Showing stock validation error dialog');
    
    let errorText = '‚ùå Stock Validation Failed:\n\n';
    errorMessages.forEach(message => {
        errorText += '‚Ä¢ ' + message + '\n';
    });
    errorText += '\nPlease update your cart and try again.';
    
    alert(errorText);
}

// Debug function to check cart items structure
function debugCartItemsStructure(selectedItems) {
    console.log('üîç DEBUG: Cart items structure');
    selectedItems.forEach((item, index) => {
        console.log(`Item ${index + 1}:`, {
            id: item.id,
            productId: item.productId,
            variantId: item.variantId,
            quantity: item.quantity,
            productName: item.product?.name,
            variantInfo: item.product?.variant,
            hasVariantId: !!item.variantId,
            variantIdType: typeof item.variantId
        });
    });
}

// Debug function to verify variant exists in database
async function debugVariantInDatabase(variantId) {
    console.log(`üîç DEBUG: Checking if variant ${variantId} exists in database`);
    
    try {
        const { data, error, count } = await supabase
            .from('product_variants')
            .select('*', { count: 'exact' })
            .eq('id', variantId);
        
        console.log('üìä Variant query result:', {
            variantId,
            found: !!data && data.length > 0,
            count,
            data,
            error
        });
        
        if (data && data.length > 0) {
            console.log('‚úÖ Variant found:', data[0]);
        } else {
            console.error('‚ùå Variant not found or error:', error);
        }
        
        return data && data.length > 0;
    } catch (error) {
        console.error('‚ùå Error checking variant:', error);
        return false;
    }
}

// Function to rollback stock reservations if order fails
async function rollbackStockReservations(reservedItems) {
    console.log('üîÑ Rolling back stock reservations for', reservedItems.length, 'items...');
    
    for (const item of reservedItems) {
        try {
            const { error } = await supabase
                .from('product_variants')
                .update({ 
                    available_stock: item.previousStock,
                    last_stock_update: new Date().toISOString()
                })
                .eq('id', item.variantId);

            if (error) {
                console.error(`‚ùå Failed to rollback stock for ${item.productName}:`, error);
            } else {
                console.log(`‚úÖ Rolled back stock for ${item.productName}: ${item.newStock} ‚Üí ${item.previousStock}`);
            }
        } catch (error) {
            console.error(`Error rolling back stock for ${item.productName}:`, error);
        }
    }
}

// REPLACE showOrderSuccessMessage function in your cart.html
function showOrderSuccessMessage(orderIdValue, checkoutData, selectedTotal, n8nSuccess, deductedComponents) {
    let successMessage = 'üéâ Order submitted successfully!\n\n';

    if (n8nSuccess) {
        successMessage += 'üì± You will receive a WhatsApp message shortly with your order details.\n\n';
        successMessage += '‚ö° IMPORTANT NEXT STEPS:\n';
        successMessage += '1. Check your WhatsApp for order details\n';
        successMessage += '2. Reply "confirm" to proceed with your order\n';
        successMessage += '3. Your order will only be sent to admin AFTER confirmation\n';
        successMessage += '4. Complete payment after confirmation\n\n';
        successMessage += '‚ö†Ô∏è Your order will NOT be processed until you confirm via WhatsApp!\n\n';
    } else {
        successMessage += '‚ö†Ô∏è WhatsApp notification could not be sent. Please contact us directly.\n\n';
    }

    successMessage += `üìã Order ID: ${orderIdValue}\n`;
    successMessage += `üöö Delivery: ${checkoutData.deliveryMethod.replace('_', ' ').toUpperCase()}\n`;
    successMessage += `üë®‚Äçüíº Assigned to: ${checkoutData.driver}\n`;

    if (checkoutData.isUrgent) {
        successMessage += 'üö® This order is marked as URGENT\n';
    }

    successMessage += '\nüì¶ SHARED COMPONENTS UPDATED:\n';
    if (deductedComponents && deductedComponents.length > 0) {
        successMessage += '\nüîó Stock deducted from shared component inventory:\n';
        
        // Group by component type for better display
        const sharedComponents = [];
        const uniqueComponents = [];
        
        deductedComponents.forEach(component => {
            if (component.componentSku.startsWith('CB-') || 
                component.componentSku.startsWith('LHL-') || 
                component.componentSku.includes('SOCKET') ||
                component.componentSku.includes('CANBUS')) {
                sharedComponents.push(component);
            } else {
                uniqueComponents.push(component);
            }
        });
        
        if (sharedComponents.length > 0) {
            successMessage += '\nüîå Shared Socket/Canbus Components:\n';
            sharedComponents.forEach(component => {
                successMessage += `‚Ä¢ ${component.componentSku} (${component.componentName}): `;
                successMessage += `${component.deductedQuantity} units deducted `;
                successMessage += `(Stock: ${component.previousCurrentStock} ‚Üí ${component.newCurrentStock})\n`;
                
                // Show which products are affected
                if (component.affectedVariants && component.affectedVariants.length > 1) {
                    successMessage += `  üìä Affects: ${component.affectedVariants.map(v => v.itemName).join(', ')}\n`;
                }
            });
        }
        
        if (uniqueComponents.length > 0) {
            successMessage += '\nüì± Product-Specific Casings:\n';
            uniqueComponents.forEach(component => {
                successMessage += `‚Ä¢ ${component.componentSku} (${component.componentName}): `;
                successMessage += `${component.deductedQuantity} units deducted `;
                successMessage += `(Stock: ${component.previousCurrentStock} ‚Üí ${component.newCurrentStock})\n`;
            });
        }
        
        successMessage += `\n‚úÖ Total: ${deductedComponents.length} components updated in shared inventory.\n`;
        successMessage += 'üìä All products using these components now show updated stock levels.\n';
        successMessage += 'üîÑ Socket stock affects Complete Package availability across all products.\n';
    }

    successMessage += '\nüí≥ Payment will be required after WhatsApp confirmation.';
    successMessage += `\n\nTotal Amount: RM ${checkoutData.finalAmount.toFixed(2)}`;
    
    if (checkoutData.finalAmount > selectedTotal) {
        successMessage += ` (includes RM 10.00 delivery fee)`;
    }

    alert(successMessage);
}

// HELPER: Check component stock levels across products
async function checkComponentStockAcrossProducts(componentSku) {
    console.log(`üîç Checking how component ${componentSku} affects multiple products...`);
    
    try {
        // Get the component
        const { data: component, error: compError } = await supabase
            .from('components')
            .select('id, sku, name, available_stock')
            .eq('sku', componentSku)
            .single();
        
        if (compError || !component) {
            console.error('Component not found:', componentSku);
            return;
        }
        
        // Find all variants using this component
        const { data: variantComponents, error: vcError } = await supabase
            .from('variant_components')
            .select(`
                variant_id,
                quantity,
                product_variants (
                    id,
                    variant_name,
                    variant_sku,
                    products (
                        name,
                        model,
                        brand_id
                    )
                )
            `)
            .eq('component_id', component.id);
        
        if (vcError) {
            console.error('Error finding variants:', vcError);
            return;
        }
        
        console.log(`üìä Component ${componentSku} stock: ${component.available_stock} units`);
        console.log(`üîó Used by ${variantComponents.length} product variants:`);
        
        variantComponents.forEach(vc => {
            const variant = vc.product_variants;
            const product = variant.products;
            console.log(`  - ${product.name} (${variant.variant_name}): Uses ${vc.quantity} unit(s) per item`);
        });
        
        return {
            component,
            affectedVariants: variantComponents
        };
        
    } catch (error) {
        console.error('Error checking component stock:', error);
    }
}

        // Combined checkout dialog function - replaces all separate prompts
        function showCombinedCheckoutDialog(user, total) {
            return new Promise((resolve) => {
                // Create dialog overlay
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                overlay.style.display = 'flex';
                overlay.style.justifyContent = 'center';
                overlay.style.alignItems = 'center';
                overlay.style.zIndex = '10000';
                overlay.style.overflowY = 'auto';
                overlay.style.padding = '20px 0';

                // Create dialog box
                const dialog = document.createElement('div');
                dialog.style.backgroundColor = 'white';
                dialog.style.borderRadius = '8px';
                dialog.style.padding = '25px';
                dialog.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
                dialog.style.width = '800px';
                dialog.style.maxWidth = '90%';
                dialog.style.maxHeight = '90vh';
                dialog.style.overflowY = 'auto';

                // Dialog header
                const header = document.createElement('div');
                header.style.fontSize = '24px';
                header.style.fontWeight = 'bold';
                header.style.marginBottom = '20px';
                header.style.color = '#2c3e50';
                header.style.borderBottom = '1px solid #eee';
                header.style.paddingBottom = '10px';
                header.textContent = 'Order Summary';

                // Order summary section (like Image 2)
                const summarySection = document.createElement('div');
                summarySection.style.marginBottom = '25px';

                // Create table for order summary
                const summaryTable = document.createElement('table');
                summaryTable.style.width = '100%';
                summaryTable.style.borderCollapse = 'collapse';
                summaryTable.style.marginBottom = '15px';

                // Table header
                const tableHeader = document.createElement('thead');
                tableHeader.innerHTML = `
            <tr>
                <th style="text-align: left; padding: 8px 15px 15px 0; border-bottom: 1px solid #ddd; font-weight: 500;">Product</th>
                <th style="text-align: center; padding: 8px 15px 15px 0; border-bottom: 1px solid #ddd; font-weight: 500;">Quantity</th>
                <th style="text-align: right; padding: 8px 15px 15px 0; border-bottom: 1px solid #ddd; font-weight: 500;">Price</th>
                <th style="text-align: right; padding: 8px 0 15px 0; border-bottom: 1px solid #ddd; font-weight: 500;">Total</th>
            </tr>
        `;
                summaryTable.appendChild(tableHeader);

                // Table body
                const tableBody = document.createElement('tbody');

                // Calculate total items and display them
                let selectedItems = [];
                cartItems.forEach(item => {
                    const checkbox = document.getElementById(`select-item-${item.id}`);
                    if (checkbox && checkbox.checked) {
                        selectedItems.push(item);

                        const row = document.createElement('tr');
                        row.innerHTML = `
                    <td style="padding: 12px 15px 12px 0; border-bottom: 1px solid #eee;">${item.product.name}</td>
                    <td style="text-align: center; padding: 12px 15px 12px 0; border-bottom: 1px solid #eee;">${item.quantity}</td>
                    <td style="text-align: right; padding: 12px 15px 12px 0; border-bottom: 1px solid #eee;">RM ${item.product.price.toFixed(2)}</td>
                    <td style="text-align: right; padding: 12px 0 12px 0; border-bottom: 1px solid #eee;">RM ${(item.quantity * item.product.price).toFixed(2)}</td>
                `;
                        tableBody.appendChild(row);
                    }
                });

                summaryTable.appendChild(tableBody);

                // Table footer with total
                const tableFooter = document.createElement('tfoot');
                tableFooter.innerHTML = `
                    <tr>
                        <td colspan="3" style="text-align: right; padding: 12px 15px 5px 0;">Subtotal:</td>
                        <td style="text-align: right; padding: 12px 0 5px 0;">RM ${total.toFixed(2)}</td>
                    </tr>
                    <tr id="delivery-fee-row" style="display: none;">
                        <td colspan="3" style="text-align: right; padding: 5px 15px 5px 0;">Delivery Fee:</td>
                        <td id="delivery-fee-amount" style="text-align: right; padding: 5px 0 5px 0;">RM 10.00</td>
                    </tr>
                    <tr>
                        <td colspan="3" style="text-align: right; padding: 5px 15px 0 0; font-weight: bold; border-top: 1px solid #ddd; padding-top: 12px;">Total:</td>
                        <td id="final-total-amount" style="text-align: right; padding: 5px 0 0 0; font-weight: bold; color: #e21b1b; border-top: 1px solid #ddd; padding-top: 12px;">RM ${total.toFixed(2)}</td>
                    </tr>
                `;
                summaryTable.appendChild(tableFooter);

                summarySection.appendChild(summaryTable);

                // Shipping & Payment section header (like Image 2)
                const shippingHeader = document.createElement('div');
                shippingHeader.style.fontSize = '20px';
                shippingHeader.style.fontWeight = 'bold';
                shippingHeader.style.marginTop = '30px';
                shippingHeader.style.marginBottom = '20px';
                shippingHeader.style.color = '#2c3e50';
                shippingHeader.textContent = 'Shipping & Payment';

                // Create form container
                const formContainer = document.createElement('div');
                formContainer.style.display = 'flex';
                formContainer.style.flexDirection = 'column';
                formContainer.style.gap = '20px';

                // 1. Delivery Method Section
                const deliveryMethodLabel = document.createElement('div');
                deliveryMethodLabel.textContent = 'Delivery Method';
                deliveryMethodLabel.style.fontWeight = '500';
                deliveryMethodLabel.style.marginBottom = '10px';

                const deliveryMethodSelect = document.createElement('div');
                deliveryMethodSelect.style.position = 'relative';
                deliveryMethodSelect.style.width = '100%';

                const deliverySelectBox = document.createElement('select');
                deliverySelectBox.id = 'delivery-method';
                deliverySelectBox.style.width = '100%';
                deliverySelectBox.style.padding = '12px 15px';
                deliverySelectBox.style.borderRadius = '4px';
                deliverySelectBox.style.border = '1px solid #ced4da';
                deliverySelectBox.style.appearance = 'none';
                deliverySelectBox.style.backgroundColor = 'white';
                deliverySelectBox.style.cursor = 'pointer';

                // Add options
                const deliveryOptions = [
                    { value: 'local_driver', label: 'Local Driver (Selangor/KL Area)' },
                    { value: 'overstate_driver', label: 'Overstate Driver (Other States)' },
                    { value: 'lalamove_urgent', label: 'Lalamove (Urgent Delivery)' },
                    { value: 'self_pickup', label: 'Self Pickup (Autolab Address)' }
                ];

                deliveryOptions.forEach(option => {
                    const optionEl = document.createElement('option');
                    optionEl.value = option.value;
                    optionEl.textContent = option.label;
                    deliverySelectBox.appendChild(optionEl);
                });

                // Add dropdown arrow
                const selectArrow = document.createElement('div');
                selectArrow.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none;">
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
        `;

                deliveryMethodSelect.appendChild(deliverySelectBox);
                deliveryMethodSelect.appendChild(selectArrow);

                const deliveryFeeNotice = document.createElement('div');
                deliveryFeeNotice.id = 'delivery-fee-notice';
                deliveryFeeNotice.style.fontSize = '12px';
                deliveryFeeNotice.style.color = '#e21b1b';
                deliveryFeeNotice.style.marginTop = '5px';
                deliveryFeeNotice.style.display = 'none';
                deliveryFeeNotice.style.fontWeight = '500';
                deliveryFeeNotice.textContent = 'A delivery fee of RM 10.00 will be applied.';

                const deliveryMethodSection = document.createElement('div');
                deliveryMethodSection.appendChild(deliveryMethodLabel);
                deliveryMethodSection.appendChild(deliveryMethodSelect);
                deliveryMethodSection.appendChild(deliveryFeeNotice);

                // Add event listener to handle address section visibility
                deliverySelectBox.addEventListener('change', function () {
                    const addressSection = document.getElementById('address-section');
                    if (this.value === 'self_pickup') {
                        addressSection.style.display = 'none';
                    } else {
                        addressSection.style.display = 'block';
                    }

                    const deliveryFeeRow = document.getElementById('delivery-fee-row');
                    const finalTotalAmountElem = document.getElementById('final-total-amount');
                    const deliveryFeeNoticeElem = document.getElementById('delivery-fee-notice');

                    if (this.value === 'lalamove_urgent') {
                        deliveryFeeRow.style.display = 'table-row';
                        deliveryFeeNoticeElem.style.display = 'block';
                        finalTotalAmountElem.textContent = `RM ${(total + 10).toFixed(2)}`;
                    } else {
                        deliveryFeeRow.style.display = 'none';
                        deliveryFeeNoticeElem.style.display = 'none';
                        finalTotalAmountElem.textContent = `RM ${total.toFixed(2)}`;
                    }

                    // Automatically handle urgent status
                    const urgentCheckbox = document.getElementById('urgent-checkbox');
                    const urgentContainer = urgentCheckbox.parentElement;
                    if (this.value === 'lalamove_urgent') {
                        urgentCheckbox.checked = true;
                        urgentCheckbox.disabled = true;
                        urgentContainer.style.borderColor = '#e21b1b';
                        urgentContainer.style.backgroundColor = '#fff3f3';
                    } else {
                        urgentCheckbox.checked = false;
                        urgentCheckbox.disabled = false;
                        urgentContainer.style.borderColor = '#ddd';
                        urgentContainer.style.backgroundColor = 'white';
                    }
                });

                // 2. Address Section (styled like Image 3)
                const addressSection = document.createElement('div');
                addressSection.id = 'address-section';

                const addressLabel = document.createElement('div');
                addressLabel.textContent = 'Delivery Address';
                addressLabel.style.fontWeight = '500';
                addressLabel.style.marginBottom = '15px';

                const addressesContainer = document.createElement('div');
                addressesContainer.style.display = 'flex';
                addressesContainer.style.gap = '15px';
                addressesContainer.style.flexWrap = 'wrap';

                // Primary address card
                const primaryCard = document.createElement('div');
                primaryCard.className = 'address-card';
                primaryCard.style.flex = '1';
                primaryCard.style.minWidth = '250px';
                primaryCard.style.border = '1px solid #e21b1b';
                primaryCard.style.borderRadius = '8px';
                primaryCard.style.padding = '15px';
                primaryCard.style.position = 'relative';
                primaryCard.style.cursor = 'pointer';
                primaryCard.style.backgroundColor = '#fff3f3';

                // Primary badge
                const primaryBadge = document.createElement('span');
                primaryBadge.textContent = 'Primary';
                primaryBadge.style.position = 'absolute';
                primaryBadge.style.top = '10px';
                primaryBadge.style.right = '10px';
                primaryBadge.style.backgroundColor = '#e21b1b';
                primaryBadge.style.color = 'white';
                primaryBadge.style.padding = '3px 8px';
                primaryBadge.style.borderRadius = '4px';
                primaryBadge.style.fontSize = '12px';
                primaryBadge.style.fontWeight = 'bold';

                // Primary radio
                const primaryRadio = document.createElement('input');
                primaryRadio.type = 'radio';
                primaryRadio.id = 'primary-address-radio';
                primaryRadio.name = 'addressType';
                primaryRadio.value = 'primary';
                primaryRadio.checked = true;
                primaryRadio.style.marginRight = '10px';

                // Primary address text area
                const primaryAddressText = document.createElement('textarea');
                primaryAddressText.id = 'primary-address-text';
                primaryAddressText.style.width = '100%';
                primaryAddressText.style.padding = '10px';
                primaryAddressText.style.borderRadius = '4px';
                primaryAddressText.style.border = '1px solid #ced4da';
                primaryAddressText.style.minHeight = '80px';
                primaryAddressText.style.marginTop = '10px';
                primaryAddressText.value = user.address || '';

                primaryCard.appendChild(primaryBadge);
                primaryCard.appendChild(primaryRadio);
                primaryCard.appendChild(document.createTextNode('Primary Address'));
                primaryCard.appendChild(primaryAddressText);

                // Alternative address card
                const altCard = document.createElement('div');
                altCard.className = 'address-card';
                altCard.style.flex = '1';
                altCard.style.minWidth = '250px';
                altCard.style.border = '1px solid #ddd';
                altCard.style.borderRadius = '8px';
                altCard.style.padding = '15px';
                altCard.style.position = 'relative';
                altCard.style.cursor = 'pointer';

                // Alternative radio
                const altRadio = document.createElement('input');
                altRadio.type = 'radio';
                altRadio.id = 'alt-address-radio';
                altRadio.name = 'addressType';
                altRadio.value = 'alternative';
                altRadio.style.marginRight = '10px';

                // Alternative address text area
                const altAddressText = document.createElement('textarea');
                altAddressText.id = 'alt-address-text';
                altAddressText.style.width = '100%';
                altAddressText.style.padding = '10px';
                altAddressText.style.borderRadius = '4px';
                altAddressText.style.border = '1px solid #ced4da';
                altAddressText.style.minHeight = '80px';
                altAddressText.style.marginTop = '10px';
                altAddressText.value = user.alternative_address || '';

                altCard.appendChild(altRadio);
                altCard.appendChild(document.createTextNode('Alternative Address'));
                altCard.appendChild(altAddressText);

                // Add click handlers for address cards
                primaryCard.addEventListener('click', function () {
                    primaryRadio.checked = true;
                    primaryCard.style.borderColor = '#e21b1b';
                    primaryCard.style.backgroundColor = '#fff3f3';
                    altCard.style.borderColor = '#ddd';
                    altCard.style.backgroundColor = 'white';
                });

                altCard.addEventListener('click', function () {
                    altRadio.checked = true;
                    altCard.style.borderColor = '#e21b1b';
                    altCard.style.backgroundColor = '#fff3f3';
                    primaryCard.style.borderColor = '#ddd';
                    primaryCard.style.backgroundColor = 'white';
                });

                addressesContainer.appendChild(primaryCard);
                addressesContainer.appendChild(altCard);

                addressSection.appendChild(addressLabel);
                addressSection.appendChild(addressesContainer);

                // 3. Payment Notice Section (replacing payment options)
                const paymentNoticeLabel = document.createElement('div');
                paymentNoticeLabel.textContent = 'Payment Information';
                paymentNoticeLabel.style.fontWeight = '500';
                paymentNoticeLabel.style.marginBottom = '10px';

                const paymentNoticeBox = document.createElement('div');
                paymentNoticeBox.style.padding = '15px';
                paymentNoticeBox.style.border = '1px solid #17a2b8';
                paymentNoticeBox.style.borderRadius = '8px';
                paymentNoticeBox.style.backgroundColor = '#e8f4f8';
                paymentNoticeBox.style.color = '#0c5460';

                const paymentNoticeText = document.createElement('div');
                paymentNoticeText.innerHTML = `
                    <strong>üì± Payment Process:</strong><br>
                    1. After placing your order, you'll receive a WhatsApp confirmation<br>
                    2. Reply "confirm" to proceed with your order<br>
                    3. Payment link will be sent after confirmation<br>
                    4. Complete payment to process your order
                `;
                paymentNoticeText.style.lineHeight = '1.5';

                paymentNoticeBox.appendChild(paymentNoticeText);

                const paymentMethodSection = document.createElement('div');
                paymentMethodSection.appendChild(paymentNoticeLabel);
                paymentMethodSection.appendChild(paymentNoticeBox);

                // 4. Urgent Order Section
                const urgentOrderLabel = document.createElement('div');
                urgentOrderLabel.textContent = 'Mark as Urgent Order';
                urgentOrderLabel.style.fontWeight = '500';
                urgentOrderLabel.style.marginBottom = '10px';

                const urgentCheckboxContainer = document.createElement('div');
                urgentCheckboxContainer.style.display = 'flex';
                urgentCheckboxContainer.style.alignItems = 'center';
                urgentCheckboxContainer.style.padding = '10px';
                urgentCheckboxContainer.style.border = '1px solid #ddd';
                urgentCheckboxContainer.style.borderRadius = '8px';
                urgentCheckboxContainer.style.cursor = 'pointer';

                const urgentCheckbox = document.createElement('input');
                urgentCheckbox.type = 'checkbox';
                urgentCheckbox.id = 'urgent-checkbox';
                urgentCheckbox.style.marginRight = '10px';

                urgentCheckboxContainer.appendChild(urgentCheckbox);
                urgentCheckboxContainer.appendChild(document.createTextNode('This order is urgent and needs immediate attention'));

                // Add click handler for urgent checkbox
                urgentCheckboxContainer.addEventListener('click', function () {
                    urgentCheckbox.checked = !urgentCheckbox.checked;

                    if (urgentCheckbox.checked) {
                        urgentCheckboxContainer.style.borderColor = '#e21b1b';
                        urgentCheckboxContainer.style.backgroundColor = '#fff3f3';

                        // Disable driver option when urgent is checked
                        const driverOption = deliverySelectBox.querySelector('option[value="driver"]');
                        driverOption.disabled = true;

                        // If driver was selected, change to lalamove
                        if (deliverySelectBox.value === 'driver') {
                            deliverySelectBox.value = 'lalamove';
                        }
                    } else {
                        urgentCheckboxContainer.style.borderColor = '#ddd';
                        urgentCheckboxContainer.style.backgroundColor = 'white';

                        // Re-enable driver option when urgent is unchecked
                        const driverOption = deliverySelectBox.querySelector('option[value="driver"]');
                        driverOption.disabled = false;
                    }
                });

                const urgentOrderSection = document.createElement('div');
                urgentOrderSection.appendChild(urgentOrderLabel);
                urgentOrderSection.appendChild(urgentCheckboxContainer);

                // Buttons section
                const buttonsContainer = document.createElement('div');
                buttonsContainer.style.display = 'flex';
                buttonsContainer.style.justifyContent = 'flex-end';
                buttonsContainer.style.gap = '15px';
                buttonsContainer.style.marginTop = '30px';

                // Cancel button
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.style.padding = '12px 20px';
                cancelButton.style.backgroundColor = '#f8f9fa';
                cancelButton.style.color = '#212529';
                cancelButton.style.border = '1px solid #dee2e6';
                cancelButton.style.borderRadius = '4px';
                cancelButton.style.cursor = 'pointer';
                cancelButton.style.fontWeight = '500';

                // Place Order button
                const placeOrderButton = document.createElement('button');
                placeOrderButton.textContent = 'Place Order';
                placeOrderButton.style.padding = '12px 25px';
                placeOrderButton.style.backgroundColor = '#e21b1b';
                placeOrderButton.style.color = 'white';
                placeOrderButton.style.border = 'none';
                placeOrderButton.style.borderRadius = '4px';
                placeOrderButton.style.cursor = 'pointer';
                placeOrderButton.style.fontWeight = '600';

                // Add event listeners for buttons
                cancelButton.addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    resolve(null);
                });

                placeOrderButton.addEventListener('click', async () => {
                    // Get delivery method
                    const deliveryMethod = deliverySelectBox.value;
                    const deliveryMethodLabel = deliverySelectBox.options[deliverySelectBox.selectedIndex].text;

                    // Handle address based on delivery method
                    let deliveryAddress = '';
                    let driver = '';

                    if (deliveryMethod === 'self_pickup') {
                        deliveryAddress = 'Self Pickup (Autolab Address)';
                        driver = 'Self Pickup';
                    } else {
                        // Get selected address
                        const addressType = document.querySelector('input[name="addressType"]:checked').value;
                        const primaryAddressValue = document.getElementById('primary-address-text').value.trim();
                        const altAddressValue = document.getElementById('alt-address-text').value.trim();

                        if (addressType === 'primary') {
                            deliveryAddress = primaryAddressValue || 'Address to be provided';
                        } else {
                            deliveryAddress = altAddressValue || 'Alternative address to be provided';
                        }

                        // Set driver based on delivery method
                        driver = deliveryMethodLabel;

                        // Update user's addresses in database if changed
                        const userUpdates = {};

                        if (primaryAddressValue !== user.address) {
                            userUpdates.address = primaryAddressValue;
                        }

                        if (altAddressValue !== user.alternative_address) {
                            userUpdates.alternative_address = altAddressValue;
                        }

                        // Only update if changes were made
                        if (Object.keys(userUpdates).length > 0) {
                            const { error } = await supabase
                                .from('customers')
                                .update(userUpdates)
                                .eq('id', user.id);

                            if (error) {
                                console.error('Error updating addresses:', error);
                            } else {
                                // Update session storage
                                user.address = primaryAddressValue;
                                user.alternative_address = altAddressValue;
                                localStorage.setItem('currentUser', JSON.stringify(user));
                            }
                        }
                    }

                    // Get urgent status based on dropdown and checkbox
                    const isUrgent = document.getElementById('urgent-checkbox').checked;

                    let finalTotal = total;
                    if (deliveryMethod === 'lalamove_urgent') {
                        finalTotal += 10;
                    }

                    // Return checkout data (payment always false initially)
                    document.body.removeChild(overlay);
                    resolve({
                        deliveryMethod: deliveryMethodLabel,
                        deliveryAddress,
                        isPaid: false, // Always false - payment after WhatsApp confirmation
                        isUrgent,
                        driver: driver,
                        finalAmount: finalTotal
                    });
                });

                buttonsContainer.appendChild(cancelButton);
                buttonsContainer.appendChild(placeOrderButton);

                // Assemble all sections
                formContainer.appendChild(deliveryMethodSection);
                formContainer.appendChild(addressSection);
                formContainer.appendChild(paymentMethodSection);
                formContainer.appendChild(urgentOrderSection);

                dialog.appendChild(header);
                dialog.appendChild(summarySection);
                dialog.appendChild(shippingHeader);
                dialog.appendChild(formContainer);
                dialog.appendChild(buttonsContainer);

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                // Initialize state - if self-pickup is selected initially, hide address section
                if (deliverySelectBox.value === 'self_pickup') {
                    addressSection.style.display = 'none';
                }
            });
        }

        // Handle logout
        async function logout() {
            const { error } = await supabase.auth.signOut();
            if (error) {
                console.error('Error signing out:', error);
                alert('Error signing out. Please try again.');
            } else {
                // Clear session storage
                localStorage.removeItem('currentUser');

                // Redirect to login page
                window.location.href = "customer-login.html";
            }
        }

    </script>
</body>

</html>